import { randomUUID } from 'crypto';
import { Payment } from '../models/Payment.js';
import { UserAppAccess } from '../models/UserAppAccess.js';

// Helper to get accessible appIds for child_admin
async function getAccessibleAppIds(user) {
  if (user.role === 'admin') {
    return null; // null means all apps
  }

  const accessRecords = await UserAppAccess.find({ userId: user._id }).populate('appId');
  return accessRecords.map((a) => a.appId?.appId).filter(Boolean);
}

const IST_OFFSET_MINUTES = 330;

function toIST(date) {
  return new Date(date.getTime() + IST_OFFSET_MINUTES * 60 * 1000);
}

function fromIST(date) {
  return new Date(date.getTime() - IST_OFFSET_MINUTES * 60 * 1000);
}

function startOfDayIST(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  return d;
}

function endOfDayIST(date) {
  const d = new Date(date);
  d.setHours(23, 59, 59, 999);
  return d;
}

// Helper function to get date range based on filter (computed in IST, returned in UTC)
function getDateRange(filter) {
  const nowUTC = new Date();
  const nowIST = toIST(nowUTC);
  let startIST, endIST;

  switch (filter) {
    case 'today': {
      startIST = startOfDayIST(nowIST);
      endIST = endOfDayIST(nowIST);
      break;
    }
    case 'yesterday': {
      const yesterdayIST = new Date(nowIST);
      yesterdayIST.setDate(yesterdayIST.getDate() - 1);
      startIST = startOfDayIST(yesterdayIST);
      endIST = endOfDayIST(yesterdayIST);
      break;
    }
    case 'last_10_min': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 10 * 60 * 1000);
      break;
    }
    case 'last_30_min': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 30 * 60 * 1000);
      break;
    }
    case 'last_1_hour': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 60 * 60 * 1000);
      break;
    }
    case 'last_3_hour': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 3 * 60 * 60 * 1000);
      break;
    }
    case 'last_6_hour': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 6 * 60 * 60 * 1000);
      break;
    }
    case 'last_12_hours': {
      endIST = new Date(nowIST);
      startIST = new Date(endIST.getTime() - 12 * 60 * 60 * 1000);
      break;
    }
    case 'this_weekend': {
      const refIST = new Date(nowIST);
      const day = refIST.getDay(); // 0 = Sunday, 6 = Saturday
      const sundayIST = startOfDayIST(refIST);
      sundayIST.setDate(sundayIST.getDate() - day);
      startIST = sundayIST;
      const weekendEndIST = new Date(sundayIST);
      if (day === 0 || day === 6) {
        const todayEndIST = endOfDayIST(refIST);
        endIST = todayEndIST;
      } else {
        weekendEndIST.setDate(weekendEndIST.getDate() + 6);
        endIST = endOfDayIST(weekendEndIST);
      }
      break;
    }
    case 'this_month': {
      const startMonthIST = startOfDayIST(new Date(nowIST));
      startMonthIST.setDate(1);
      startIST = startMonthIST;
      endIST = endOfDayIST(nowIST);
      break;
    }
    default:
      return null; // No date filter for unknown values
  }

  return { startDate: fromIST(startIST), endDate: fromIST(endIST) };
}

export async function createOrUpdatePayment(req, res) {
  const { appId, ptStatus, collectionId, ant, amount, transactionDate } = req.body || {};

  // uuid is no longer required - will be generated by backend
  const missing = ['appId', 'ptStatus', 'collectionId', 'ant']
    .filter((k) => typeof req.body?.[k] !== 'string' || req.body[k].trim() === '');

  if (missing.length > 0) {
    return res.status(400).json({ error: 'Missing or invalid fields', fields: missing });
  }

  // Validate ptStatus enum
  if (!['success', 'failed', 'retry'].includes(ptStatus)) {
    return res.status(400).json({ error: 'ptStatus must be success, failed, or retry' });
  }

  // Generate UUID automatically
  const uuid = randomUUID();

  // Convert ant to amount if amount not provided
  const paymentAmount = amount !== undefined ? Number(amount) : Number(ant) || 0;

  const paymentData = {
    uuid,
    appId: appId.trim(),
    ptStatus,
    collectionId: collectionId.trim(),
    ant: ant.trim(),
    amount: paymentAmount,
    transactionDate: transactionDate ? new Date(transactionDate) : new Date(),
  };

  try {
    const payment = await Payment.create(paymentData);
    // Remove amount from response
    const { amount, ...paymentResponse } = payment.toObject();
    return res.status(201).json({ success: true, data: paymentResponse });
  } catch (err) {
    // Check if it's a duplicate UUID error (shouldn't happen, but just in case)
    if (err.code === 11000) {
      // If UUID collision (very rare), retry with new UUID
      const retryUuid = randomUUID();
      paymentData.uuid = retryUuid;
      const retryPayment = await Payment.create(paymentData);
      const { amount, ...paymentResponse } = retryPayment.toObject();
      return res.status(201).json({ success: true, data: paymentResponse });
    }
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function listPayments(req, res) {
  const { appId, page = 1, limit = 50, filter, startDate, endDate } = req.query;
  
  // Build app filter - respect user's app access
  const appFilter = {};
  if (typeof appId === 'string' && appId.trim() !== '') {
    const requestedAppId = appId.trim();
    appFilter.appId = requestedAppId;
    // Check if user has access to this app
    if (req.user.role === 'child_admin') {
      const accessibleApps = await getAccessibleAppIds(req.user);
      if (!accessibleApps.includes(requestedAppId)) {
        return res.status(403).json({ error: 'Access denied for this app' });
      }
    }
  } else if (req.user.role === 'child_admin') {
    // If no appId specified, only show user's accessible apps
    const accessibleApps = await getAccessibleAppIds(req.user);
    if (accessibleApps.length === 0) {
      return res.json({ count: 0, total: 0, page: 1, totalPages: 0, data: [] });
    }
    appFilter.appId = { $in: accessibleApps };
  }
  
  // Build date filter
  let dateFilter = {};
  if (filter && filter !== 'custom_date') {
    const dateRange = getDateRange(filter);
    if (dateRange) {
      dateFilter.transactionDate = { $gte: dateRange.startDate, $lte: dateRange.endDate };
    }
  } else if (filter === 'custom_date' && startDate && endDate) {
    dateFilter.transactionDate = {
      $gte: new Date(startDate),
      $lte: new Date(endDate),
    };
  }
  
  const queryFilter = { ...appFilter, ...dateFilter };
  
  try {
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.max(1, Math.min(100, Number(limit))); // Max 100 per page
    const skip = (pageNum - 1) * limitNum;

    const [payments, total] = await Promise.all([
      Payment.find(queryFilter)
        .select('-amount')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      Payment.countDocuments(queryFilter),
    ]);

    return res.json({
      count: payments.length,
      total,
      page: pageNum,
      totalPages: Math.ceil(total / limitNum),
      data: payments,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function getPaymentStatistics(req, res) {
  const { appId, filter, startDate, endDate } = req.query;
  
  // Build app filter - respect user's app access
  const appFilter = {};
  if (typeof appId === 'string' && appId.trim() !== '') {
    const requestedAppId = appId.trim();
    appFilter.appId = requestedAppId;
    // Check if user has access to this app
    if (req.user.role === 'child_admin') {
      const accessibleApps = await getAccessibleAppIds(req.user);
      if (!accessibleApps.includes(requestedAppId)) {
        return res.status(403).json({ error: 'Access denied for this app' });
      }
    }
  } else if (req.user.role === 'child_admin') {
    // If no appId specified, only show user's accessible apps
    const accessibleApps = await getAccessibleAppIds(req.user);
    if (accessibleApps.length === 0) {
      return res.json({
        totalTransactions: 0,
        successCount: 0,
        failedCount: 0,
        retryCount: 0,
        totalSales: 0,
      });
    }
    appFilter.appId = { $in: accessibleApps };
  }
  
  // Build date filter
  let dateFilter = {};
  if (filter && filter !== 'custom_date') {
    const dateRange = getDateRange(filter);
    if (dateRange) {
      dateFilter.transactionDate = { $gte: dateRange.startDate, $lte: dateRange.endDate };
    }
  } else if (filter === 'custom_date' && startDate && endDate) {
    dateFilter.transactionDate = {
      $gte: new Date(startDate),
      $lte: new Date(endDate),
    };
  }
  
  const queryFilter = { ...appFilter, ...dateFilter };
  
  try {
    // Get aggregated statistics
    const [stats, successPayments] = await Promise.all([
      Payment.aggregate([
        { $match: queryFilter },
        {
          $group: {
            _id: null,
            totalTransactions: { $sum: 1 },
            successCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'success'] }, 1, 0] },
            },
            failedCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'failed'] }, 1, 0] },
            },
            retryCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'retry'] }, 1, 0] },
            },
          },
        },
      ]),
      // Only get success payments for totalSales calculation
      Payment.find({ ...queryFilter, ptStatus: 'success' }).select('ant'),
    ]);

    // Calculate total sales only from successful payments by parsing ant field from string to int
    const totalSales = successPayments.reduce((sum, payment) => {
      const antValue = parseInt(payment.ant, 10) || 0;
      return sum + antValue;
    }, 0);

    const result = stats[0] || {
      totalTransactions: 0,
      successCount: 0,
      failedCount: 0,
      retryCount: 0,
    };

    return res.json({
      totalTransactions: result.totalTransactions,
      successCount: result.successCount,
      failedCount: result.failedCount,
      retryCount: result.retryCount,
      totalSales: totalSales,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function getPaymentByUuid(req, res) {
  const { uuid } = req.params;
  try {
    const payment = await Payment.findOne({ uuid }).select('-amount');
    if (!payment) return res.status(404).json({ error: 'Not found' });
    return res.json({ data: payment });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}


