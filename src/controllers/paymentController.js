import { randomUUID } from 'crypto';
import { Payment } from '../models/Payment.js';

// Helper function to get date range based on filter
function getDateRange(filter) {
  const now = new Date();
  let startDate, endDate;

  switch (filter) {
    case 'today': {
      startDate = new Date(now);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(now);
      endDate.setHours(23, 59, 59, 999);
      break;
    }
    case 'yesterday': {
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      startDate = new Date(yesterday.setHours(0, 0, 0, 0));
      endDate = new Date(yesterday.setHours(23, 59, 59, 999));
      break;
    }
    case 'last_10_min': {
      startDate = new Date(now.getTime() - 10 * 60 * 1000);
      endDate = new Date(now);
      break;
    }
    case 'last_30_min': {
      startDate = new Date(now.getTime() - 30 * 60 * 1000);
      endDate = new Date(now);
      break;
    }
    case 'last_1_hour': {
      startDate = new Date(now.getTime() - 60 * 60 * 1000);
      endDate = new Date(now);
      break;
    }
    case 'last_3_hour': {
      startDate = new Date(now.getTime() - 3 * 60 * 60 * 1000);
      endDate = new Date(now);
      break;
    }
    case 'last_6_hour': {
      startDate = new Date(now.getTime() - 6 * 60 * 60 * 1000);
      endDate = new Date(now);
      break;
    }
    case 'this_weekend': {
      const day = now.getDay(); // 0 = Sunday, 6 = Saturday
      const diff = now.getDate() - day; // Days to subtract to get to Sunday
      startDate = new Date(now);
      startDate.setDate(diff); // Set to Sunday
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(now);
      if (day === 0 || day === 6) {
        // If it's already weekend, include today
        endDate.setHours(23, 59, 59, 999);
      } else {
        // Otherwise, go to last Saturday
        endDate.setDate(diff + 6);
        endDate.setHours(23, 59, 59, 999);
      }
      break;
    }
    case 'this_month': {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(now);
      endDate.setHours(23, 59, 59, 999);
      break;
    }
    default:
      return null; // No date filter for unknown values
  }

  return { startDate, endDate };
}

export async function createOrUpdatePayment(req, res) {
  const { appId, ptStatus, collectionId, ant, amount, transactionDate } = req.body || {};

  // uuid is no longer required - will be generated by backend
  const missing = ['appId', 'ptStatus', 'collectionId', 'ant']
    .filter((k) => typeof req.body?.[k] !== 'string' || req.body[k].trim() === '');

  if (missing.length > 0) {
    return res.status(400).json({ error: 'Missing or invalid fields', fields: missing });
  }

  // Validate ptStatus enum
  if (!['success', 'failed', 'retry'].includes(ptStatus)) {
    return res.status(400).json({ error: 'ptStatus must be success, failed, or retry' });
  }

  // Generate UUID automatically
  const uuid = randomUUID();

  // Convert ant to amount if amount not provided
  const paymentAmount = amount !== undefined ? Number(amount) : Number(ant) || 0;

  const paymentData = {
    uuid,
    appId: appId.trim(),
    ptStatus,
    collectionId: collectionId.trim(),
    ant: ant.trim(),
    amount: paymentAmount,
    transactionDate: transactionDate ? new Date(transactionDate) : new Date(),
  };

  try {
    const payment = await Payment.create(paymentData);
    // Remove amount from response
    const { amount, ...paymentResponse } = payment.toObject();
    return res.status(201).json({ success: true, data: paymentResponse });
  } catch (err) {
    // Check if it's a duplicate UUID error (shouldn't happen, but just in case)
    if (err.code === 11000) {
      // If UUID collision (very rare), retry with new UUID
      const retryUuid = randomUUID();
      paymentData.uuid = retryUuid;
      const retryPayment = await Payment.create(paymentData);
      const { amount, ...paymentResponse } = retryPayment.toObject();
      return res.status(201).json({ success: true, data: paymentResponse });
    }
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function listPayments(req, res) {
  const { appId, page = 1, limit = 50, filter, startDate, endDate } = req.query;
  
  // Build app filter
  const appFilter = {};
  if (typeof appId === 'string' && appId.trim() !== '') {
    appFilter.appId = appId.trim();
  }
  
  // Build date filter
  let dateFilter = {};
  if (filter && filter !== 'custom_date') {
    const dateRange = getDateRange(filter);
    if (dateRange) {
      dateFilter.transactionDate = { $gte: dateRange.startDate, $lte: dateRange.endDate };
    }
  } else if (filter === 'custom_date' && startDate && endDate) {
    dateFilter.transactionDate = {
      $gte: new Date(startDate),
      $lte: new Date(endDate),
    };
  }
  
  const queryFilter = { ...appFilter, ...dateFilter };
  
  try {
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.max(1, Math.min(100, Number(limit))); // Max 100 per page
    const skip = (pageNum - 1) * limitNum;

    const [payments, total] = await Promise.all([
      Payment.find(queryFilter)
        .select('-amount')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      Payment.countDocuments(queryFilter),
    ]);

    return res.json({
      count: payments.length,
      total,
      page: pageNum,
      totalPages: Math.ceil(total / limitNum),
      data: payments,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function getPaymentStatistics(req, res) {
  const { appId, filter, startDate, endDate } = req.query;
  
  // Build app filter
  const appFilter = {};
  if (typeof appId === 'string' && appId.trim() !== '') {
    appFilter.appId = appId.trim();
  }
  
  // Build date filter
  let dateFilter = {};
  if (filter && filter !== 'custom_date') {
    const dateRange = getDateRange(filter);
    if (dateRange) {
      dateFilter.transactionDate = { $gte: dateRange.startDate, $lte: dateRange.endDate };
    }
  } else if (filter === 'custom_date' && startDate && endDate) {
    dateFilter.transactionDate = {
      $gte: new Date(startDate),
      $lte: new Date(endDate),
    };
  }
  
  const queryFilter = { ...appFilter, ...dateFilter };
  
  try {
    // Get aggregated statistics
    const [stats, successPayments] = await Promise.all([
      Payment.aggregate([
        { $match: queryFilter },
        {
          $group: {
            _id: null,
            totalTransactions: { $sum: 1 },
            successCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'success'] }, 1, 0] },
            },
            failedCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'failed'] }, 1, 0] },
            },
            retryCount: {
              $sum: { $cond: [{ $eq: ['$ptStatus', 'retry'] }, 1, 0] },
            },
          },
        },
      ]),
      // Only get success payments for totalSales calculation
      Payment.find({ ...queryFilter, ptStatus: 'success' }).select('ant'),
    ]);

    // Calculate total sales only from successful payments by parsing ant field from string to int
    const totalSales = successPayments.reduce((sum, payment) => {
      const antValue = parseInt(payment.ant, 10) || 0;
      return sum + antValue;
    }, 0);

    const result = stats[0] || {
      totalTransactions: 0,
      successCount: 0,
      failedCount: 0,
      retryCount: 0,
    };

    return res.json({
      totalTransactions: result.totalTransactions,
      successCount: result.successCount,
      failedCount: result.failedCount,
      retryCount: result.retryCount,
      totalSales: totalSales,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function getPaymentByUuid(req, res) {
  const { uuid } = req.params;
  try {
    const payment = await Payment.findOne({ uuid }).select('-amount');
    if (!payment) return res.status(404).json({ error: 'Not found' });
    return res.json({ data: payment });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}


