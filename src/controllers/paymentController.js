import { randomUUID } from 'crypto';
import { Payment } from '../models/Payment.js';

export async function createOrUpdatePayment(req, res) {
  const { appId, ptStatus, collectionId, ant, amount, transactionDate } = req.body || {};

  // uuid is no longer required - will be generated by backend
  const missing = ['appId', 'ptStatus', 'collectionId', 'ant']
    .filter((k) => typeof req.body?.[k] !== 'string' || req.body[k].trim() === '');

  if (missing.length > 0) {
    return res.status(400).json({ error: 'Missing or invalid fields', fields: missing });
  }

  // Validate ptStatus enum
  if (!['success', 'failed', 'retry'].includes(ptStatus)) {
    return res.status(400).json({ error: 'ptStatus must be success, failed, or retry' });
  }

  // Generate UUID automatically
  const uuid = randomUUID();

  // Convert ant to amount if amount not provided
  const paymentAmount = amount !== undefined ? Number(amount) : Number(ant) || 0;

  const paymentData = {
    uuid,
    appId: appId.trim(),
    ptStatus,
    collectionId: collectionId.trim(),
    ant: ant.trim(),
    amount: paymentAmount,
    transactionDate: transactionDate ? new Date(transactionDate) : new Date(),
  };

  try {
    const payment = await Payment.create(paymentData);
    // Remove amount from response
    const { amount, ...paymentResponse } = payment.toObject();
    return res.status(201).json({ success: true, data: paymentResponse });
  } catch (err) {
    // Check if it's a duplicate UUID error (shouldn't happen, but just in case)
    if (err.code === 11000) {
      // If UUID collision (very rare), retry with new UUID
      const retryUuid = randomUUID();
      paymentData.uuid = retryUuid;
      const retryPayment = await Payment.create(paymentData);
      const { amount, ...paymentResponse } = retryPayment.toObject();
      return res.status(201).json({ success: true, data: paymentResponse });
    }
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function listPayments(req, res) {
  const { appId, page = 1, limit = 50 } = req.query;
  const filter = {};
  
  if (typeof appId === 'string' && appId.trim() !== '') {
    filter.appId = appId.trim();
  }
  
  try {
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.max(1, Math.min(100, Number(limit))); // Max 100 per page
    const skip = (pageNum - 1) * limitNum;

    const [payments, total] = await Promise.all([
      Payment.find(filter)
        .select('-amount')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      Payment.countDocuments(filter),
    ]);

    return res.json({
      count: payments.length,
      total,
      page: pageNum,
      totalPages: Math.ceil(total / limitNum),
      data: payments,
    });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}

export async function getPaymentByUuid(req, res) {
  const { uuid } = req.params;
  try {
    const payment = await Payment.findOne({ uuid }).select('-amount');
    if (!payment) return res.status(404).json({ error: 'Not found' });
    return res.json({ data: payment });
  } catch (err) {
    return res.status(500).json({ error: 'Database error', details: err.message });
  }
}


